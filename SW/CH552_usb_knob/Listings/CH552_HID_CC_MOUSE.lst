C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CH552_HID_CC_MOUSE
OBJECT MODULE PLACED IN .\Objects\CH552_HID_CC_MOUSE.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE CH552_HID_CC_MOUSE.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND P
                    -RINT(.\Listings\CH552_HID_CC_MOUSE.lst) OBJECT(.\Objects\CH552_HID_CC_MOUSE.obj)

line level    source

   1          #include "CH552.H"
   2          #include "CH552_USB.h"
   3          #include "CH552_HID_CC_MOUSE.h"
   4          
   5          #define HID_DEV_DESCR_SIZE 18
   6          #define HID_CONF_DESCR_SIZE 59
   7          #define HID_MOUSE_REPORT_DESCR_SIZE 52
   8          #define HID_CC_REPORT_DESCR_SIZE 25
   9          #define HID_MOUSE_REPORT_SIZE 4
  10          #define HID_CC_REPORT_SIZE 3
  11          
  12          UINT8 xdata ep0_buffer[HID_ENDP0_BUF_SIZE];
  13          UINT8 xdata ep1_buffer[HID_ENDP1_BUF_SIZE];
  14          UINT8 xdata ep2_buffer[HID_ENDP2_BUF_SIZE];
  15          
  16          #define hid_setup_buf ((PUSB_SETUP_REQ)ep0_buffer)
  17          
  18          UINT8 hid_setup_req;
  19          UINT8 hid_setup_type;
  20          UINT16 hid_setup_len;
  21          
  22          UINT8 code* descriptor_ptr;
  23          UINT8 hid_address;
  24          UINT8 hid_config;
  25          
  26          volatile UINT8 hid_mouse_report_pending;
  27          volatile UINT8 hid_mouse_idle_rate;
  28          UINT8 hid_mouse_protocol;
  29          volatile UINT8 hid_cc_report_pending;
  30          volatile UINT8 hid_cc_idle_rate;
  31          UINT8 hid_cc_protocol;
  32          
  33          /* USB Device Descriptors */
  34          UINT8 code hid_device_descriptor[] =
  35          { 
  36              HID_DEV_DESCR_SIZE,                         // bLength
  37              0x01,                           // bDescriptorType
  38              0x10, 0x01,                     // bcdUSB
  39              0x00,                           // bDeviceClass
  40              0x00,                           // bDeviceSubClass
  41              0x00,                           // bDeviceProtocol
  42              HID_ENDP0_SIZE,                                     // bMaxPacketSize0
  43              0x86, 0x1A,                     // idVendor
  44              0x0C, 0xFE,                     // idProduct
  45              0x00, 0x01,                     // bcdDevice
  46              0x01,                           // iManufacturer
  47              0x02,                           // iProduct
  48              0x03,                           // iSerialNumber
  49              0x01,                           // bNumConfigurations
  50          };
  51          
  52          /* USB Configration Descriptors */
  53          UINT8 code hid_config_descriptor[] =
  54          { 
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 2   

  55              /* Configuration Descriptor */
  56              0x09,                           // bLength
  57              0x02,                           // bDescriptorType
  58              HID_CONF_DESCR_SIZE & 0xFF, HID_CONF_DESCR_SIZE >> 8, // wTotalLength
  59              0x02,                           // bNumInterfaces
  60              0x01,                           // bConfigurationValue
  61              0x00,                           // iConfiguration
  62              0x80,                           // bmAttributes: bus powered, no wakeup
  63              0x32,                           // MaxPower: 100mA
  64          
  65              /* Interface Descriptor (Mouse) */
  66              0x09,                           // bLength
  67              0x04,                           // bDescriptorType
  68              0x00,                           // bInterfaceNumber
  69              0x00,                           // bAlternateSetting
  70              0x01,                           // bNumEndpoints
  71              0x03,                           // bInterfaceClass
  72              0x01,                           // bInterfaceSubClass
  73              0x02,                           // bInterfaceProtocol: Mouse
  74              0x04,                           // iInterface
  75          
  76              /* HID Descriptor (Mouse) */
  77              0x09,                           // bLength
  78              0x21,                           // bDescriptorType
  79              0x10, 0x01,                     // bcdHID
  80              0x00,                           // bCountryCode
  81              0x01,                           // bNumDescriptors
  82              0x22,                           // bDescriptorType
  83              HID_MOUSE_REPORT_DESCR_SIZE & 0xFF, HID_MOUSE_REPORT_DESCR_SIZE >> 8, // wDescriptorLength
  84          
  85              /* Endpoint Descriptor (Mouse) */
  86              0x07,                           // bLength
  87              0x05,                           // bDescriptorType
  88              0x81,                           // bEndpointAddress: IN Endpoint 1
  89              0x03,                           // bmAttributes
  90              HID_ENDP1_SIZE & 0xFF, HID_ENDP1_SIZE >> 8, // wMaxPacketSize
  91              0x01,                            // bInterval: 1mS
  92                  
  93                  /* Interface Descriptor (Consumer Control)*/
  94              0x09,                           // bLength
  95              0x04,                           // bDescriptorType
  96              0x01,                           // bInterfaceNumber
  97              0x00,                           // bAlternateSetting
  98              0x01,                           // bNumEndpoints
  99              0x03,                           // bInterfaceClass: HID
 100              0x01,                           // bInterfaceSubClass: boot interface
 101              0x01,                           // bInterfaceProtocol: Keyboard
 102              0x05,                           // iInterface
 103          
 104              /* HID Descriptor */
 105              0x09,                           // bLength
 106              0x21,                           // bDescriptorType
 107              0x10, 0x01,                     // bcdHID
 108              0x00,                           // bCountryCode
 109              0x01,                           // bNumDescriptors
 110              0x22,                           // bDescriptorType
 111              HID_CC_REPORT_DESCR_SIZE & 0xFF, HID_CC_REPORT_DESCR_SIZE >> 8, // wDescriptorLength
 112          
 113              /* Endpoint Descriptor (Mouse) */
 114              0x07,                           // bLength
 115              0x05,                           // bDescriptorType
 116              0x82,                           // bEndpointAddress: IN Endpoint 2
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 3   

 117              0x03,                           // bmAttributes
 118              HID_ENDP2_SIZE & 0xFF, HID_ENDP2_SIZE >> 8, // wMaxPacketSize
 119              0x01                            // bInterval: 1mS
 120          };
 121          
 122          /* HID Report Descriptor (Mouse) */
 123          UINT8 code hid_mouse_report_descriptor[] =
 124          {
 125              0x05, 0x01,                     // Usage Page (Generic Desktop)
 126              0x09, 0x02,                     // Usage (Mouse)
 127              0xA1, 0x01,                     // Collection (Application)
 128              0x09, 0x01,                     // Usage (Pointer)
 129              0xA1, 0x00,                     // Collection (Physical)
 130              0x05, 0x09,                     // Usage Page (Button)
 131              0x19, 0x01,                     // Usage Minimum (Button 1)
 132              0x29, 0x03,                     // Usage Maximum (Button 3)
 133              0x15, 0x00,                     // Logical Minimum (0)
 134              0x25, 0x01,                     // Logical Maximum (1)
 135              0x75, 0x01,                     // Report Size (1)
 136              0x95, 0x03,                     // Report Count (3)
 137              0x81, 0x02,                     // Input (Data,Variable,Absolute)
 138              0x75, 0x05,                     // Report Size (5)
 139              0x95, 0x01,                     // Report Count (1)
 140              0x81, 0x03,                     // Input (Constant,Variable,Absolute)
 141              0x05, 0x01,                     // Usage Page (Generic Desktop)
 142              0x09, 0x30,                     // Usage (X)
 143              0x09, 0x31,                     // Usage (Y)
 144              0x09, 0x38,                     // Usage (Wheel)
 145              0x15, 0x81,                     // Logical Minimum (-127)
 146              0x25, 0x7F,                     // Logical Maximum (127)
 147              0x75, 0x08,                     // Report Size (8)
 148              0x95, 0x03,                     // Report Count (3)
 149              0x81, 0x06,                     // Input (Data,Variable,Relative)
 150              0xC0,                           // End Collection
 151              0xC0                            // End Collection
 152          };
 153          
 154          /* HID Report Descriptor (Consumer Control) */
 155          UINT8 code hid_cc_report_descriptor[] =
 156          {
 157                  0x05, 0x0c,           // USAGE_PAGE (Consumer Devices)
 158                  0x09, 0x01,           // USAGE (Consumer Control)
 159                  0xa1, 0x01,           // COLLECTION (Application)
 160                  0x85, 0x01,           //   REPORT_ID (1)
 161                  0x19, 0x00,           //   USAGE_MINIMUM (Unassigned)
 162                  0x2a, 0x3c, 0x02,     //   USAGE_MAXIMUM (AC Format)
 163                  0x15, 0x00,           //   LOGICAL_MINIMUM (0)
 164                  0x26, 0x3c, 0x02,     //   LOGICAL_MAXIMUM (572)
 165                  0x95, 0x01,           //   REPORT_COUNT (1)
 166                  0x75, 0x10,           //   REPORT_SIZE (16)
 167                  0x81, 0x00,           //   INPUT (Data,Var,Abs)
 168                  0xc0                  // END_COLLECTION
 169          };
 170          
 171          /* USB Language String Descriptor */
 172          UINT8 code hid_string_lang_id[] =
 173          {
 174                  0x04,
 175                  0x03,
 176                  0x09,
 177                  0x04 
 178          };
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 4   

 179          
 180          /* USB Manufacturer String Descriptor */
 181          UINT8 code hid_string_vendor[] =
 182          {
 183                  14,    
 184                  0x03,           
 185                  'w',0,'c',0,'h',0,'.',0,'c',0,'n',0
 186          };
 187          
 188          /* USB Product String Descriptor */
 189          UINT8 code hid_string_product[] =
 190          {
 191              26,
 192              0x03,
 193              'U', 0, 'S', 0, 'B', 0, ' ', 0, 'C', 0, 'C', 0, ' ', 0, 'M', 0, 'o', 0, 'u', 0, 's', 0, 'e', 0
 194          };
 195          
 196          /* USB Serial String Descriptor */
 197          UINT8 code hid_string_serial[] =
 198          {
 199                  22,          
 200                  0x03,                   
 201                  'D', 0, 'E', 0, 'A', 0, 'D', 0, 'B', 0, 'E', 0 , 'E', 0, 'F', 0, '0', 0, '3', 0
 202          };
 203          
 204          void hid_copy_descriptor(UINT8 len)
 205          {
 206   1              UINT8* dest = ep0_buffer;
 207   1              while(len)
 208   1              {
 209   2                      *dest = *descriptor_ptr;
 210   2                      ++dest;
 211   2                      ++descriptor_ptr;
 212   2                      --len;
 213   2              }
 214   1      }
 215          
 216          void hid_on_out(UINT8 ep)
 217          {
 218   1              if(ep == EP_0)
 219   1              {
 220   2                      usb_set_ep0_tx_len(0);
 221   2                      usb_set_ep0_tog_res(EP_OUT_TOG_1 | EP_IN_TOG_1 | USB_OUT_RES_ACK | USB_IN_RES_NAK);
 222   2              }
 223   1      }
 224          
 225          void hid_on_in(UINT8 ep)
 226          {
 227   1              UINT8 len;
 228   1              
 229   1              if(ep == EP_0)
 230   1              {
 231   2                      if((hid_setup_type & USB_REQ_TYP_MASK) == USB_REQ_TYP_STANDARD)
 232   2                      {
 233   3                              switch(hid_setup_req)
 234   3                              {
 235   4                                      case USB_GET_DESCRIPTOR:
 236   4                                              len = hid_setup_len >= HID_ENDP0_SIZE ? HID_ENDP0_SIZE : hid_setup_len;
 237   4                                              hid_copy_descriptor(len);
 238   4                                              hid_setup_len -= len;
 239   4                                              usb_set_ep0_tx_len(len);
 240   4                                              usb_toggle_ep0_in_toggle();
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 5   

 241   4                                              break;
 242   4                                      case USB_SET_ADDRESS:
 243   4                                              usb_set_addr(hid_address);
 244   4                                              usb_set_ep0_in_res(USB_IN_RES_NAK);
 245   4                                              break;
 246   4                                      default:
 247   4                                              usb_set_ep0_tx_len(0);
 248   4                                              usb_set_ep0_in_res(USB_IN_RES_NAK);
 249   4                                              break;
 250   4                              }
 251   3                      }
 252   2                      else
 253   2                      {
 254   3                              usb_set_ep0_tx_len(0);
 255   3                              usb_set_ep0_in_res(USB_IN_RES_NAK);
 256   3                      }
 257   2              }
 258   1              
 259   1              if(ep == EP_1)
 260   1              {
 261   2                      usb_set_ep1_tx_len(0);
 262   2                      usb_set_ep1_in_res(USB_IN_RES_NAK);
 263   2                      
 264   2                      ep1_buffer[1] = 0;      //clear movement and scrolling
 265   2                      ep1_buffer[2] = 0;
 266   2                      ep1_buffer[3] = 0;
 267   2                      hid_mouse_report_pending = 0;
 268   2              }
 269   1              
 270   1              if(ep == EP_2)
 271   1              {
 272   2                      usb_set_ep2_tx_len(0);
 273   2                      usb_set_ep2_in_res(USB_IN_RES_NAK);
 274   2                      hid_cc_report_pending = 0;
 275   2              }
 276   1      }
 277          
 278          void hid_on_setup(UINT8 ep)
 279          {
 280   1              UINT8 len;
 281   1              UINT8 idx;
 282   1              
 283   1              if(ep == EP_0)
 284   1              {
 285   2                      hid_setup_len = ((UINT16)hid_setup_buf->wLengthH<<8) | (hid_setup_buf->wLengthL);
 286   2                      hid_setup_req = hid_setup_buf->bRequest;
 287   2                      hid_setup_type = hid_setup_buf->bRequestType;
 288   2                      descriptor_ptr = (UINT8 code*)NULL;
 289   2                      len = 0;
 290   2                      
 291   2                      if((hid_setup_type & USB_REQ_TYP_MASK) == USB_REQ_TYP_STANDARD)
 292   2                      {
 293   3                              switch(hid_setup_req)
 294   3                              {
 295   4                                      case USB_GET_STATUS:
 296   4                                              ep0_buffer[0] = 0x00;
 297   4                                              ep0_buffer[1] = 0x00;
 298   4                                              len = 2;
 299   4                                              break;
 300   4                                      case USB_CLEAR_FEATURE:
 301   4                                              if(((hid_setup_type & USB_REQ_RECIP_MASK) == USB_REQ_RECIP_ENDP) && !hid_setup_buf->wValueL)
 302   4                                              {
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 6   

 303   5                                                      switch(hid_setup_buf->wIndexL)
 304   5                                                      {
 305   6                                                              case 0x01:
 306   6                                                                      usb_set_ep1_out_toggle(EP_OUT_TOG_0);
 307   6                                                                      usb_set_ep1_out_res(USB_OUT_RES_ACK);
 308   6                                                                      break;
 309   6                                                              case 0x81:
 310   6                                                                      usb_set_ep1_in_toggle(EP_IN_TOG_0);
 311   6                                                                      usb_set_ep1_in_res(USB_IN_RES_NAK);
 312   6                                                                      break;
 313   6                                                              case 0x82:
 314   6                                                                      usb_set_ep2_in_toggle(EP_IN_TOG_0);
 315   6                                                                      usb_set_ep2_in_res(USB_IN_RES_NAK);
 316   6                                                                      break;
 317   6                                                              default:
 318   6                                                                      len = 0xFF;
 319   6                                                                      break;
 320   6                                                      }
 321   5                                              }
 322   4                                              else
 323   4                                              {
 324   5                                                      len = 0xFF;
 325   5                                              }
 326   4                                              break;
 327   4                                      case USB_SET_FEATURE:
 328   4                                              if(((hid_setup_type & USB_REQ_RECIP_MASK) == USB_REQ_RECIP_ENDP) && !hid_setup_buf->wValueL)
 329   4                                              {
 330   5                                                      switch(hid_setup_buf->wIndexL)
 331   5                                                      {
 332   6                                                              case 0x01:
 333   6                                                                      usb_set_ep1_out_toggle(EP_OUT_TOG_0);
 334   6                                                                      usb_set_ep1_out_res(USB_OUT_RES_STALL);
 335   6                                                                      break;
 336   6                                                              case 0x81:
 337   6                                                                      usb_set_ep1_in_toggle(EP_IN_TOG_0);
 338   6                                                                      usb_set_ep1_in_res(USB_IN_RES_STALL);
 339   6                                                                      break;
 340   6                                                              case 0x82:
 341   6                                                                      usb_set_ep2_in_toggle(EP_IN_TOG_0);
 342   6                                                                      usb_set_ep2_in_res(USB_IN_RES_STALL);
 343   6                                                                      break;
 344   6                                                              default:
 345   6                                                                      len = 0xFF;
 346   6                                                                      break;
 347   6                                                      }
 348   5                                              }
 349   4                                              else
 350   4                                              {
 351   5                                                      len = 0xFF;
 352   5                                              }
 353   4                                              break;
 354   4                                      case USB_SET_ADDRESS:
 355   4                                              hid_address = hid_setup_buf->wValueL;
 356   4                                              break;
 357   4                                      case USB_GET_DESCRIPTOR:
 358   4                                              switch(hid_setup_buf->wValueH)
 359   4                                              {
 360   5                                                      case USB_DESCR_TYP_DEVICE:
 361   5                                                              descriptor_ptr = hid_device_descriptor;
 362   5                                                              len = HID_DEV_DESCR_SIZE;
 363   5                                                              break;
 364   5                                                      case USB_DESCR_TYP_CONFIG:
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 7   

 365   5                                                              descriptor_ptr = hid_config_descriptor;
 366   5                                                              len = HID_CONF_DESCR_SIZE;
 367   5                                                              break;
 368   5                                                      case USB_DESCR_TYP_STRING:
 369   5                                                              switch(hid_setup_buf->wValueL)
 370   5                                                              {
 371   6                                                                      case 0:
 372   6                                                                              descriptor_ptr = hid_string_lang_id;
 373   6                                                                              break;
 374   6                                                                      case 1:
 375   6                                                                              descriptor_ptr = hid_string_vendor;
 376   6                                                                              break;
 377   6                                                                      case 2:
 378   6                                                                              descriptor_ptr = hid_string_product;
 379   6                                                                              break;
 380   6                                                                      case 3:
 381   6                                                                              descriptor_ptr = hid_string_serial;
 382   6                                                                              break;
 383   6                                                                      default:
 384   6                                                                              descriptor_ptr = hid_string_product;
 385   6                                                                              break;
 386   6                                                              }
 387   5                                                              len = descriptor_ptr[0];
 388   5                                                              break;
 389   5                                                      case USB_DESCR_TYP_REPORT:
 390   5                                                              if(hid_setup_buf->wIndexL == 0)
 391   5                                                              {
 392   6                                                                      //Mouse interface
 393   6                                                                      descriptor_ptr = hid_mouse_report_descriptor;
 394   6                                                                      len = HID_MOUSE_REPORT_DESCR_SIZE;
 395   6                                                              }
 396   5                                                              else
 397   5                                                              {
 398   6                                                                      //Consumer Control interface
 399   6                                                                      descriptor_ptr = hid_cc_report_descriptor;
 400   6                                                                      len = HID_CC_REPORT_DESCR_SIZE;
 401   6                                                              }
 402   5                                                              break;
 403   5                                                      default:
 404   5                                                              len = 0xFF;
 405   5                                                              break;
 406   5                                              }
 407   4                                              break;
 408   4                                      case USB_GET_CONFIGURATION:
 409   4                                              ep0_buffer[0] = hid_config;
 410   4                                              len = 1;
 411   4                                              break;
 412   4                                      case USB_SET_CONFIGURATION:
 413   4                                              hid_config = hid_setup_buf->wValueL;
 414   4                                              break;
 415   4                                      case USB_GET_INTERFACE:
 416   4                                              ep0_buffer[0] = 0;
 417   4                                              len = 1;
 418   4                                              break;
 419   4                                      case USB_SET_INTERFACE:
 420   4                                              //nothing to do here
 421   4                                              break;
 422   4                                      default:
 423   4                                              len = 0xFF;
 424   4                                              break;
 425   4                              }
 426   3                      }
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 8   

 427   2                      else if((hid_setup_type & USB_REQ_TYP_MASK) == USB_REQ_TYP_CLASS)
 428   2                      {
 429   3                              switch(hid_setup_req)
 430   3                              {
 431   4                                      case HID_GET_REPORT:
 432   4                                              if(hid_setup_buf->wIndexL == 0)
 433   4                                              {
 434   5                                                      //Mouse interface
 435   5                                                      for(idx = 0; idx < HID_MOUSE_REPORT_SIZE; ++idx)
 436   5                                                      {
 437   6                                                              ep0_buffer[idx] = ep1_buffer[idx];      //the report does not have its own buffer, it stays in ep1
 438   6                                                      }
 439   5                                                      len = HID_MOUSE_REPORT_SIZE;
 440   5                                              }
 441   4                                              else
 442   4                                              {
 443   5                                                      //Consumer Control interface
 444   5                                                      for(idx = 0; idx < HID_CC_REPORT_SIZE; ++idx)
 445   5                                                      {
 446   6                                                              ep0_buffer[idx] = ep2_buffer[idx];      //the report does not have its own buffer, it stays in ep2
 447   6                                                      }
 448   5                                                      len = HID_CC_REPORT_SIZE;
 449   5                                              }
 450   4                                              break;
 451   4                                      case HID_GET_IDLE:
 452   4                                              if(hid_setup_buf->wIndexL == 0)
 453   4                                              {
 454   5                                                      ep0_buffer[0] = hid_mouse_idle_rate;
 455   5                                                      len = 1;
 456   5                                              }
 457   4                                              else
 458   4                                              {
 459   5                                                      ep0_buffer[0] = hid_cc_idle_rate;
 460   5                                                      len = 1;
 461   5                                              }
 462   4                                              break;
 463   4                                      case HID_GET_PROTOCOL:
 464   4                                              if(hid_setup_buf->wIndexL == 0)
 465   4                                              {
 466   5                                                      ep0_buffer[0] = hid_mouse_protocol;
 467   5                                                      len = 1;
 468   5                                              }
 469   4                                              else
 470   4                                              {
 471   5                                                      ep0_buffer[0] = hid_cc_protocol;
 472   5                                                      len = 1;
 473   5                                              }
 474   4                                              break;
 475   4                                      case HID_SET_REPORT:
 476   4                                              // nothing to do here
 477   4                                              break;
 478   4                                      case HID_SET_IDLE:
 479   4                                              if(hid_setup_buf->wIndexL == 0)
 480   4                                              {
 481   5                                                      hid_mouse_idle_rate = hid_setup_buf->wValueH;
 482   5                                              }
 483   4                                              else
 484   4                                              {
 485   5                                                      hid_cc_idle_rate = hid_setup_buf->wValueH;
 486   5                                              }
 487   4                                              break;
 488   4                                      case HID_SET_PROTOCOL:
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 9   

 489   4                                              if(hid_setup_buf->wIndexL == 0)
 490   4                                              {
 491   5                                                      hid_mouse_protocol = hid_setup_buf->wValueL;
 492   5                                              }
 493   4                                              else
 494   4                                              {
 495   5                                                      hid_cc_protocol = hid_setup_buf->wValueL;
 496   5                                              }
 497   4                                              break;
 498   4                                      default:
 499   4                                              len = 0xFF;
 500   4                                              break;
 501   4                              }
 502   3                      }
 503   2                      else
 504   2                      {
 505   3                              len = 0xFF;
 506   3                      }       // end  if((hid_setup_type & USB_REQ_TYP_MASK) == USB_REQ_TYP_STANDARD)
 507   2                      
 508   2                      if(len == 0xFF)
 509   2                      {
 510   3                              hid_setup_req = 0xFF;
 511   3                              usb_set_ep0_tog_res(EP_OUT_TOG_1 | EP_IN_TOG_1 | USB_OUT_RES_STALL | USB_IN_RES_STALL);
 512   3                      }
 513   2                      else
 514   2                      {
 515   3                              if(hid_setup_len > len)
 516   3                                      hid_setup_len = len;
 517   3                              len = (hid_setup_len > HID_ENDP0_SIZE) ? HID_ENDP0_SIZE : hid_setup_len;
 518   3                              
 519   3                              if(descriptor_ptr != (UINT8 code*)NULL)
 520   3                                      hid_copy_descriptor(len);
 521   3                              
 522   3                              hid_setup_len -= len;
 523   3                              usb_set_ep0_tx_len(len);
 524   3                              usb_set_ep0_tog_res(EP_OUT_TOG_1 | EP_IN_TOG_1 | USB_OUT_RES_ACK | USB_IN_RES_EXPECT_ACK);
 525   3                      }
 526   2              }       // end if(ep == EP_0)
 527   1      }
 528          
 529          void hid_on_rst(void)
 530          {
 531   1              usb_set_ep0_tog_res(USB_OUT_RES_ACK | USB_IN_RES_NAK | EP_OUT_TOG_0 | EP_IN_TOG_0 | EP_AUTOTOG_0);
 532   1              usb_set_ep1_tog_res(USB_OUT_RES_ACK | USB_IN_RES_NAK | EP_OUT_TOG_0 | EP_IN_TOG_0 | EP_AUTOTOG_1);
 533   1              usb_set_ep2_tog_res(USB_OUT_RES_ACK | USB_IN_RES_NAK | EP_OUT_TOG_0 | EP_IN_TOG_0 | EP_AUTOTOG_1);
 534   1              
 535   1              ep1_buffer[0] = 0;
 536   1              ep1_buffer[1] = 0;
 537   1              ep1_buffer[2] = 0;
 538   1              ep1_buffer[3] = 0;
 539   1              hid_mouse_report_pending = 0;
 540   1              hid_mouse_idle_rate = 0;
 541   1              hid_mouse_protocol = 0x01;      //default to report protocol
 542   1              
 543   1              ep2_buffer[0] = 1;      //report id
 544   1              ep2_buffer[1] = 0;
 545   1              ep2_buffer[2] = 0;
 546   1              hid_cc_report_pending = 0;
 547   1              hid_cc_idle_rate = 0;
 548   1              hid_cc_protocol = 0x01; //default to report protocol
 549   1      }
 550          
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 10  

 551          usb_config_t code usb_config = 
 552          {
 553                  (UINT16)ep0_buffer,
 554                  (UINT16)ep1_buffer,
 555                  (UINT16)ep2_buffer,
 556                  0x0000,
 557                  USB_OUT_RES_ACK | USB_IN_RES_NAK | EP_OUT_TOG_0 | EP_IN_TOG_0 | EP_AUTOTOG_0,
 558                  USB_OUT_RES_ACK | USB_IN_RES_NAK | EP_OUT_TOG_0 | EP_IN_TOG_0 | EP_AUTOTOG_1,
 559                  USB_OUT_RES_ACK | USB_IN_RES_NAK | EP_OUT_TOG_0 | EP_IN_TOG_0 | EP_AUTOTOG_1,
 560                  USB_OUT_RES_ACK | USB_IN_RES_NAK | EP_OUT_TOG_0 | EP_IN_TOG_0 | EP_AUTOTOG_0,
 561                  USB_OUT_RES_ACK | USB_IN_RES_NAK | EP_OUT_TOG_0 | EP_IN_TOG_0 | EP_AUTOTOG_0,
 562                  USB_EP1_TX_EN | USB_EP1_BUF_SINGLE,
 563                  USB_EP2_TX_EN | USB_EP2_BUF_SINGLE | USB_EP3_BUF_SINGLE,
 564                  USB_INT_TRANSFER | USB_INT_RST
 565          };
 566          
 567          void hid_init(void)
 568          {
 569   1              usb_sof_callback = NULL;
 570   1              usb_out_callback = hid_on_out;
 571   1              usb_in_callback = hid_on_in;
 572   1              usb_setup_callback = hid_on_setup;
 573   1              usb_rst_callback = hid_on_rst;
 574   1              usb_suspend_callback = NULL;
 575   1              
 576   1              usb_init(&usb_config);
 577   1      }
 578          
 579          void hid_mouse_send_report(void)
 580          {
 581   1              hid_mouse_report_pending = 1;
 582   1              usb_set_ep1_tx_len(HID_MOUSE_REPORT_SIZE);
 583   1              usb_set_ep1_in_res(USB_IN_RES_EXPECT_ACK);
 584   1      }
 585          
 586          void hid_mouse_press(UINT8 buttons)
 587          {
 588   1              ep1_buffer[0] = ep1_buffer[0] | buttons;
 589   1              hid_mouse_send_report();
 590   1      }
 591          
 592          void hid_mouse_release(UINT8 buttons)
 593          {
 594   1              ep1_buffer[0] = ep1_buffer[0] & ~buttons;
 595   1              hid_mouse_send_report();
 596   1      }
 597          
 598          void hid_mouse_move(UINT8 x_rel, UINT8 y_rel)
 599          {
 600   1              ep1_buffer[1] += x_rel;
 601   1              ep1_buffer[2] += y_rel;
 602   1              hid_mouse_send_report();
 603   1      }
 604          
 605          void hid_mouse_scroll(UINT8 scroll_rel)
 606          {
 607   1              ep1_buffer[3] += scroll_rel;
 608   1              hid_mouse_send_report();
 609   1      }
 610          
 611          void hid_cc_send_report(void)
 612          {
C51 COMPILER V9.60.0.0   CH552_HID_CC_MOUSE                                                08/06/2024 09:36:55 PAGE 11  

 613   1              hid_cc_report_pending = 1;
 614   1              usb_set_ep2_tx_len(HID_CC_REPORT_SIZE);
 615   1              usb_set_ep2_in_res(USB_IN_RES_EXPECT_ACK);
 616   1      }
 617          
 618          void hid_cc_press(UINT16 key)
 619          {
 620   1              ep2_buffer[1] = (UINT8)key;
 621   1              ep2_buffer[2] = (UINT8)(key >> 8);
 622   1              hid_cc_send_report();
 623   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1353    ----
   CONSTANT SIZE    =    236    ----
   XDATA SIZE       =     36       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
